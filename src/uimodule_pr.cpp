/**
 * Author: Frano Petric
 * Version: 0.9
 * Date: 23.4.2014.
 */

#include "uimodule_pr.hpp"
#include <iostream>
#include <fstream>
#include <alvalue/alvalue.h>
#include <alcommon/alproxy.h>
#include <alcommon/albroker.h>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/thread.hpp>
#include <boost/lambda/lambda.hpp>
#include <qi/log.hpp>
#include <althread/alcriticalsection.h>

struct PlayRequestInterface::Impl {

    /**
      * IP and port of the remote NAOqi which is running on the other robot
      */
    std::string remoteIP;
    int remotePort;

    /**
      * Proxy to local ALMemory
      */
    boost::shared_ptr<AL::ALMemoryProxy> memoryProxy;

    /**
      * Proxy to ALBehaviorManager for running pointing behavior
      */
    boost::shared_ptr<AL::ALBehaviorManagerProxy> behaviorProxy;

    /**
      * Proxy to ALAudioPlayer for sound reproduction
      */
    boost::shared_ptr<AL::ALAudioPlayerProxy> playerProxy;

    /**
      * Proxy to ALLeds module
      */
    boost::shared_ptr<AL::ALLedsProxy> ledProxy;

    /**
      * Module object
      */
    PlayRequestInterface &module;

    /**
      * Mutex used to lock callback functions, making them thread safe
      */
    boost::shared_ptr<AL::ALMutex> fCallbackMutex;

    bool started;

    /**
      * Struct constructor, initializes module instance and callback mutex
      */
    Impl(PlayRequestInterface &mod) : module(mod), fCallbackMutex(AL::ALMutex::createALMutex()) {

        // Create proxies
        try {
            memoryProxy = boost::shared_ptr<AL::ALMemoryProxy>(new AL::ALMemoryProxy(mod.getParentBroker()));
            behaviorProxy = boost::shared_ptr<AL::ALBehaviorManagerProxy>(new AL::ALBehaviorManagerProxy(mod.getParentBroker()));
            playerProxy = boost::shared_ptr<AL::ALAudioPlayerProxy>(new AL::ALAudioPlayerProxy(mod.getParentBroker()));
            ledProxy = boost::shared_ptr<AL::ALLedsProxy>(new AL::ALLedsProxy(mod.getParentBroker()));
        }
        catch (const AL::ALError& e) {
            qiLogError("PlayRequestInterface") << "Error creating proxies: " << e.toString() << std::endl;
        }
        // Declare events that are generated by this module
        memoryProxy->declareEvent("StartSessionPR", "PlayRequestInterface");
        memoryProxy->declareEvent("ChildCalledPR", "PlayRequestInterface");
        started = false;


    }
};

PlayRequestInterface::PlayRequestInterface(boost::shared_ptr<AL::ALBroker> pBroker, const std::string& pName) :  AL::ALModule(pBroker, pName) {

    setModuleDescription("Interface module, reacting to events generated by the Logger module, calling child by either name or by using special phrases");

    functionName("onTactilTouched", getName(), "FrontTactilTouched callback, starts the session");
    BIND_METHOD(PlayRequestInterface::onTactilTouched);

    functionName("callChild", getName(), "CallChild callback, plays the sound");
    addParam("key", "Memory key storing data related to the event");
    addParam("value", "Value with which event is raised");
    addParam("msg", "Message provided by the module which generated the event");
    BIND_METHOD(PlayRequestInterface::callChild);

    functionName("endSession", getName(), "EndSession callback, resets the Interface");
    BIND_METHOD(PlayRequestInterface::endSession);

    functionName("startTask", getName(), "Method to enable the task by subscribing to the FronTactilTouched event");
    BIND_METHOD(PlayRequestInterface::startTask);

//    functionName("setRemoteConnection", getName(), "Method to enable the task by subscribing to the FronTactilTouched event");
//    BIND_METHOD(Interface::setRemoteConnection);
}

PlayRequestInterface::~PlayRequestInterface() {
    // Cleanup code
}

void PlayRequestInterface::init() {
   // This method overrides ALModule::init
    try {
        // Create object
        impl = boost::shared_ptr<Impl>(new Impl(*this));
        // Initialize ALModule
        AL::ALModule::init();
    }
    catch (const AL::ALError& e) {
        qiLogError("PlayRequestInterface") << e.what() << std::endl;
    }
    qiLogVerbose("PlayRequestInterface") << "PlayRequestInterface initialized" << std::endl;
}

void PlayRequestInterface::startTask(const std::string& todo) {
    if(impl->started) {
        return;
    }
    impl->started = true;
    if(todo == "start") {
        // Subscribe to events which can be triggered during the session
        try {
            impl->memoryProxy->subscribeToEvent("CallChildPR", "PlayRequestInterface", "callChild");
            impl->memoryProxy->subscribeToEvent("EndSessionPR", "PlayRequestInterface", "endSession");
        }
        catch (const AL::ALError& e) {
            qiLogError("PlayRequestInterface") << "Error subscribing to events" << e.toString() << std::endl;
        }
        // Signal the start of the session by changing eye color (unblocking call)
        impl->ledProxy->post.fadeRGB("FaceLeds", 0x00FF00, 1.5);
        // Raise event that the session should start
        impl->memoryProxy->raiseEvent("StartSessionPR", AL::ALValue(1));

    }
    else if(todo == "enable") {
        // Subscribe to event FronTactilTouched, which signals the start of the session
        impl->memoryProxy->subscribeToEvent("FrontTactilTouched", "PlayRequestInterface", "onTactilTouched");
    }
}

void PlayRequestInterface::onTactilTouched() {
    // Callback is thread safe as long as ALCriticalSection object exists
    AL::ALCriticalSection section(impl->fCallbackMutex);
    // Unsubscribe from the event
    impl->memoryProxy->unsubscribeToEvent("FrontTactilTouched", "PlayRequestInterface");
    // Subscribe to events which can be triggered during the session
    // These events are generated by the other robot
    try {
        impl->memoryProxy->subscribeToEvent("CallChildPR", "PlayRequestInterface", "callChild");
        impl->memoryProxy->subscribeToEvent("EndSessionPR", "PlayRequestInterface", "endSession");
    }
    catch (const AL::ALError& e) {
        qiLogError("PlayRequestInterface") << "Error subscribing to events: " << e.toString() << std::endl;
    }
    // Signal the start of the session by changing eye color (unblocking call)
    impl->ledProxy->post.fadeRGB("FaceLeds", 0x00FF00, 1.5);
    // Raise event that the session should start
    impl->memoryProxy->raiseEvent("StartSessionPR", AL::ALValue(1));
}

void PlayRequestInterface::callChild(const std::string &key, const AL::ALValue &value, const AL::ALValue &msg) {
    // Thread safety
    AL::ALCriticalSection section(impl->fCallbackMutex);
    // Unsubscribing
    impl->memoryProxy->unsubscribeToEvent("CallChildPR", "PlayRequestInterface");

    if((int)value == 1 || (int)value == 2) {
        impl->behaviorProxy->runBehavior("Pucketanje");
    }
    else if((int)value == 3) {
        impl->behaviorProxy->runBehavior("Lupi_dlanom");
    }
    else if((int)value == 4) {
        impl->behaviorProxy->runBehavior("Hura");
    }

    // Notify the Logger module that child was called
    impl->memoryProxy->raiseEvent("ChildCalledPR", value);

    // Subscribe to the CallChild event again
    impl->memoryProxy->subscribeToEvent("CallChildPR", "PlayRequestInterface", "callChild");
}

void PlayRequestInterface::endSession() {
    // Thread safety
    AL::ALCriticalSection section(impl->fCallbackMutex);
    // Unsubscribe
    impl->memoryProxy->unsubscribeToEvent("EndSessionPR", "PlayRequestInterface");
    // Signal the start of the session by changing eye color (unblocking call)
    impl->ledProxy->post.fadeRGB("FaceLeds", 0x0000FF, 1.5);
    // Reset subscriptions
    try {
        impl->memoryProxy->unsubscribeToEvent("CallChildPR", "PlayRequestInterface");

    }
    catch (const AL::ALError& e) {
        qiLogError("PlayRequestInterface") << "Error managing events while reseting" << e.toString() << std::endl;
    }
    impl->started = false;
}

//void Interface::setRemoteConnection(std::string& IP, int& port) {
//    impl->remoteIP = IP;
//    impl->remotePort = port;
//    // Open proxy to ALMemory of the other robot
//    try{
//        impl->memoryProxyRemote = boost::shared_ptr<AL::ALMemoryProxy>(new AL::ALMemoryProxy(impl->remoteIP, impl->remotePort));
//    }
//    catch (const AL::ALError& e) {
//        qiLogError("Interface") << "Error connecting to the other robot: " << e.toString() << std::endl;
//    }
//}

void PlayRequestInterface::enableTask(const std::string &start) {
    // enable starting of the task by subscribing to FrontTactilTouched
    impl->memoryProxy->subscribeToEvent("FrontTactilTouched", "PlayRequestInterface", "onTactilTouched");
}
